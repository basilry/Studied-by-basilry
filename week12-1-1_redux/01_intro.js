// <1> 인트로 - 전반적인 개념

// 리덕스 : 자바스크립트 어플리케이션들을 위한 예측가능한 상태의 저장소

// 소프트웨어를 만들 때 가장 큰 문제는 '복잡성'이다.
// 이러한 코드의 복잡성을 낮추고, 더 복잡한 애플리케이션을 만드는데에 도전할 수 있다.


// 1. 리덕스는 하나의 상태를 갖는다는게 특징이다.
// 여기서 상태는 객체이다. state = {};
// 데이터를 한 곳에 몰아넣어 중앙집중적으로 관리하기 쉽게 만든다.


// 2. 리덕스는 데이터를 외부와 엄격하게 차단한다.
// 그럼 어떻게 쓰는가? 디스패치와 리듀서라는 녀석을 통해서만 쓸 수 있다.
// dispatch, reducer. 직접적으로 스테이트의 값을 바꿀 수 없다.
// 데이터를 가져오는 것도 똑같다. getState라는 녀석을 통해서만 가능하다.

// 이렇게 데이터를 직접적으로 외부에서 바꿀 수 없게끔 하여,
// 이 어플리케이션을 보다 예측 가능하게끔 만드는 것이다.


// 3. 데이터가 바뀌면 바뀌었다는 것을 알려주는 메소드가 따로 있다.
// 즉 각각의 애플리케이션은 서로에 대해 신경쓸 일이 없이 자기 할 일만 하면 된다.
// 개발자 입장에서도 특정한 부품에 대해서만 신경쓰면 되기 때문에 편해진다.

// 이렇다보니 각각의 상태변화가 서로에게 영향을 주지 않기 때문에 undo와 redo를 사용하기 쉽다.


// 4. 리덕스를 사용하면 현재뿐만 아니라 과거의 어느 상태로 돌아가서 문제해결을 할 수 있게끔 한다.
// time travel이라고도 하는 기능.


// 5. 리덕스의 이러한 특징들을 사용하면 '핫 모듈 리로딩'을 할 수 있다.
// 즉, 애플리케이션은 새로 리프레쉬가 되지만 데이터는 그대로 남아있기 때문에,
// 새로 데이터를 입력할 필요가 없게끔 하여 효율성을 상승시킨다.





// <2> 소개 - 전체적인 지도

// 순수한 리덕스만을 살펴볼 것이다.
// 리액트와 궁합이 맞긴 하지만 이것만 할 것임.

// 전체적인 지도를 보자.

// store라는 곳에 state, reducer, dispatch, subscribe, getState가 있고,
// 외부에는 action과 render가 있다.


// store를 은행이라고 생각해보자.
// 스토어는 정보들을 저장하는 곳이다. 글목록, 글, 키, 리스트..

// 스토어에는 state가 있고, 절대로 바뀔 수 없는 존재이다. 함부로 접근이 불가능하다.

// 스토어를 만들면서 reducer를 만들어서 공급해 줘야 한다. 이 녀석이 리덕스에서 가장 어렵다.

// render는 외부에서 ui를 만들어주는 우리가 짜야할 코드이다. 현재상태를 반영하는 ui이다.

// action은 외부에서 데이터의 변화된 값을 스토어로 전달해주는 역할을 한다.

// state에 직접적으로 접근이 안되기 때문에 dispatch, subscribe, getState라는 것을 통해 접근해야 한다.
// getState를 통해 render가 state의 값을 받아와 ui에 렌더링 할 수 있다.
// subscribe를 통해 render가 state의 변화되는 값을 실시간으로 ui에 렌더링 할 수 있다.


// dispatch라는 창구는 외부 ui의 변화된 데이터 값이 action을 거쳐 왔을 때,
// reducer를 통해 변화된 데이터 값을 리턴하여 state의 새로운 값을 만들다.

// 여기서 reducer는 state를 입력값으로 받고, action을 창조하고, 새로운 state 값을 만들어서 리턴해주는,
// state를 가공하는 가공자이다.

// 이 상황에서 state가 변경이되면, 이러한 변경상태를 구독자들에게 모두 알려줘야 한다.
// 이를 subscribe가 render를 호출하여 getState를 통해 state에 가서 데이터를 받아오게 된다.





// <3> 리덕스가 좋은 이유는?

// 예를들어 2개의 버튼이 서로 상호작용하는 코드를 만든다고 생각해보자.
// 그럼 필요한 로직은 각 버튼당 2개이다. 자기 자신을 관리하는 로직, 다른 버튼과 상호작용하는 로직.
// 하지만 버튼이 2개니까 2*2 = 4일 것이다.

// 만약 버튼이 3개라면? 자신, 다른 a버튼, 다른 b버튼까지 총 3개이다.
// 버튼이 3개니까 3*3 = 9이다.

// 100개라면? 100*100 = 10000일 것이다. 기하급수적인 증가인 것이다.

// 이러한 상황을 타파하기 위해 데이터의 로직을 중앙집권화 하여 불필요한 코드를 축소하는 것이다.
// 각 버튼은 중앙의 데이터 저장소에 연결하고, 이 저장소에서 각 버튼에다가 알려주는 로직만 있으면 된다.

// 그렇게 되면 버튼이 2개라면 2*2 = 4개, 3개라면 2*3 = 6개, 4개라면 2*4 = 8개, 100개라면 2*100 = 200개이다.
// 10000개에서 200개로 획기적으로 줄어든 것이다.

// 이것이 리덕스가 좋은 이유 중 하나이다.


// 또한 redux devtool을 사용하게 되면, 애플리케이션의 상태가 변화가 되는 시간에 따라 앞 뒤로 왔다갔다 할 수 있다.
// 비디오 레코딩 하듯이 재생시켜 주고, 언제든지 과거로 돌아갈 수 있다. time traveling