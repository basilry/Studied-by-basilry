// <1> 기본문법, 주석

// css에다가 특정 태그를 찾아 중괄호{}를 작성하고,
// 그 안에 값들을 작성하여 스타일을 변화시킨다.

// 기본문법형태
// 선택자 { 속성: 값; }

// 선택자 = 스타일을 적용할 대상
// 속성 = 스타일의 종류(property)
// 값 = 스타일의 값(value)
//  : = ~은
//  ; = ~이다.

// 선택자 { 속성: 값; 속성: 값; }
// => 이렇게 중괄호를 열고 닫아서 스타일 범위를 확정한다.

// ex) div {color: red; margin: 20px;}
// 이렇게 쓰기 보다는..

// div {
//   color: red;
//   margin: 20px;  
// }
// 이렇게 쓰라

// 들여쓰기 내어쓰기를 통해, 코드를 이쁘게, 명시적으로 작성하는 습관을 들여라.
// 왜냐? 내가 쓰는 코드는 나만 보는 코드가 아니기 때문이다.
// 협업을 위해서라도 꼭 보기 편하게 적어야 한다.

// 내용에 대한 설명은 주석처리를 해서 적자.
// /* 내용 설명 */ 이렇게!





// <2> 선언방식

// (1) 내장방식
// <style></style>의 내용(contents)로 스타일을 작성하는 방식
// 권장하지 않는 방식이다.
// 추후 번들로 배포할 때 컴퓨터가 자동으로 내장시키는 경우가 있는데,
// 그런 경우가 아니면 굳이 할 필요가 없다.

// (2) 인라인방식
// <div style="color: red; margin: 20px;"></div>
// 선택자 없음. 어차피 그 안에다가 적기 때문.
// 이렇게 하면 너무 우선순위가 되기때문에 css파일로 수정할때 문제가 생김.
// 즉, 나중에 유지보수할 때 악영향을 미친다. 권장하지 않는 방식.

// (3) 링크방식
// <link rel="stylesheet" href="./css/main.css">
// html파일의 head 쪽에 작성하여 외부파일을 연결하는 방식.
// 병렬방식.

// (4) import 방식
// <link rel="stylesheet" href="./css/main.css">
// 이렇게 한 다음, main.css에다가 새로운 css파일을 Import해온다.
// @import url("./box.css")
// 일반적으로 많이 사용되는 방식은 아님.
// main.css 파일의 내용이 많다면 import해온 파일을 읽는 시간이 느려짐.
// 직렬방식.





// <3> 선택자 : 기본

// (1) 전체 선택자
// *로 하면 된다.
// ex)
// * {color: red;}


// (2) 태그 선택자
// 태그이름에 해당하는 요소를 선택한다.
// li를 태그선택자로 하면 li태그가 전원 선택됨.
// ex)
// li {color: red;}


// (3) 클래스 선택자
// 클래스 속성의 값이 해당하는 요소를 전원 선택한다.
// .을 앞에 쓰고 뒤에 클래스 이름을 씀.
// ex)
// .orange {color: red;}


// (4) 아이디 선택자
// 아이디 속성의 값이 해당하는 요소를 선택한다.
// #을 앞에 쓰고 뒤에 아이디 이름을 씀.
// ex)
// #orange {color: red;}





// <4> 선택자 : 복합

// (1) 일치 선택자 abc.xyz {속성: 값;}
// 선택자 abc와 xyz를 동시에 만족하는 요소를 선택하는 것.
// 붙여서 작성해야 한다.
// 단, 태그선택자를 앞에 써야 인식오류가 안생긴다.
// ex)
// span.orange {color: red;}


// (2) 자식 선택자 abc > .xyz {속성: 값;}
// 선택자 abc의 자식요소 xyz 선택
// ex)
// ul > .orange {color: red;}


// (3) 하위 선택자 abc .xyz {속성: 값;}
// 선택자 abc의 하위요소 xyz 선택
// '띄어쓰기'가 선택자의 기호.
// ex)
// div .orange{color: red;}


// (4) 인접형제 선택자*** .abc + xyz {속성: 값;}
// 선택자 abc의 다음 형제 요소 xyz '하나'를 선택.
// ex)
// .orange + li {color: red;}


// (5) 일반형제 선택자 .abc ~ xyz {속성: 값;}
// 선택자 abc의 다음 형제 요소 xyz '모두'를 선택
// ex)
// .orange ~ li {color: red;}





// <5> 선택자 : 가상클래스

// (1) abc:hover {속성: 값;}
// 해당 태그가 렌더링 된 html에서 커서를 올리면 변화를 일으킴.
// 즉, 선택자 abc 요소에 마우스 커서가 올라가 있는 동안 선택되는 것.
// 태그의 원본 스타일객체에 transition: 1s;를 하면 급변이 아닌 서서히 변화를 일으킴.


// (2) abc:active {속성: 값;}
// 선택자 abc 요소에 마우스를 클릭하고 있는 동안 선택.
// hover와는 비슷하지만 올리는 것과 클릭하는 것의 차이가 있다.


// (3) abc:focus {속성: 값;}
// 선택자 abc요소가 포커스되면 선택한다.
// focus가 될 수 있는 요소는 html 대화형 콘텐츠가 해당된다.
// input, a, button, label, select 등 여러 요소가 있다.
// ex) <input type:"text" />를 예로 들자면,
// 입력을 하기 위해 입력창을 클릭하여 입력커서가 깜빡이면 색깔이 들어오는 식이다.

// 그리고 html 대화형 콘텐츠 요소가 아니더라도,
// tabindex 속성을 사용한 요소도 focus가 될 수 있다.
// ex) <div class="box" tabindex="-1"></div>
// 이렇게 하면 박스에서도 포커스를 사용할 수 있음.

// 하지만 인풋 텍스트와 인풋 박스 둘다 포커스를 하게 되었을 시,
// 한 화면에서는 하나의 포커스만 가능 하므로, 하나를 선택하면 다른 하나의 포커스가 풀린다.


// (4) abc:first-child {속성: 값;}
// 선택자 abc가 형제 요소 중 첫째라면 선택하는 것.
// ex) .fruits span:first-child {color: red;}


// (5) abc:last-child {속성: 값;}
// 선택자 abc가 형제 요소 중 막내라면 선택하는 것.
// ex) .fruits h3:last-child {속성: 값;}


// (6) abc:nth-child(n) {속성: 값;}
// 선택자 abc가 형제 요소 중 (n)째라면 선택.
// ex) .fruits *:nth-child(2) {color: red;}

// 여기서 n은 0부터 시작한다.
// 짝수 : 2n을 쓰게되면 0,2,4,6,8...의 요소를 선택하게 된다.
// 홀수 : 2n+1을 쓰게 되면 1,3,5,7,9...의 요소를 선택하게 된다.


// (7) abc:not(xyz) {속성: 값;}
// 선택자 xyz가 아닌 abc요소를 선택.
// ex) .frutis *:not(span) {color: red;}